# -*- coding: utf-8 -*-
"""APP-TEMBLORES-4.0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v4DIpp5J0nrnrnLmC6D6ysb8hmdwz4DN
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt, welch, find_peaks
from fpdf import FPDF
import base64
from io import BytesIO
import datetime

def butter_bandpass_filter(data, lowcut, highcut, fs, order=4):
    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = butter(order, [low, high], btype='band')
    y = filtfilt(b, a, data)
    return y

def calcular_resultados(df, fs, tipo):
    resultados = []
    tests = ['Reposo', 'Postural', 'Acción']
    for i, test in enumerate(tests):
        inicio = i * 1000
        fin = (i + 1) * 1000
        for eje in ['X', 'Y', 'Z']:
            columna = f'{tipo} {eje}'
            if columna not in df.columns:
                continue
            señal = df[columna].iloc[inicio:fin].values

            # Filtro pasa banda
            señal_filtrada = butter_bandpass_filter(señal, 3, 12, fs)

            # Frecuencia dominante
            f, Pxx = welch(señal_filtrada, fs=fs, nperseg=256, window='hamming')
            peaks, _ = find_peaks(Pxx)
            if len(peaks) > 0:
                frecuencia = f[peaks[np.argmax(Pxx[peaks])]]
            else:
                frecuencia = 0.0

            # Varianza y RMS
            varianza = np.var(señal_filtrada)
            rms = np.sqrt(np.mean(señal_filtrada ** 2))

            # Amplitud estimada (solo para aceleración)
            if tipo == 'Aceleracion':
                dt = 1 / fs
                velocidad = np.cumsum(señal_filtrada) * dt
                desplazamiento = np.cumsum(velocidad) * dt
                amplitud = np.max(np.abs(desplazamiento)) * 100  # cm
            else:
                amplitud = np.max(np.abs(señal_filtrada))

            resultados.append({
                'Test': test,
                'Tipo': tipo,
                'Eje': eje,
                'Frecuencia (Hz)': round(frecuencia, 2),
                'Varianza': round(varianza, 2),
                'RMS': round(rms, 2),
                'Amplitud Max (cm)': round(amplitud, 2)
            })
    return resultados

def generar_pdf(nombre_paciente, resultados, graficos, diagnostico):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", 'B', 16)
    pdf.cell(0, 10, "Informe de Análisis de Temblores", ln=True, align="C")
    pdf.ln(10)

    pdf.set_font("Arial", '', 12)
    pdf.cell(0, 10, f"Nombre del paciente: {nombre_paciente}", ln=True)
    pdf.cell(0, 10, f"Fecha: {datetime.datetime.now().strftime('%d/%m/%Y %H:%M:%S')}", ln=True)
    pdf.ln(10)

    pdf.set_font("Arial", 'B', 14)
    pdf.cell(0, 10, "Resultados del Análisis:", ln=True)
    pdf.ln(5)

    pdf.set_font("Arial", 'B', 10)
    col_widths = [25, 25, 10, 35, 25, 25, 35]
    headers = ['Test', 'Tipo', 'Eje', 'Frecuencia (Hz)', 'Varianza', 'RMS', 'Amplitud Max (cm)']
    for i, header in enumerate(headers):
        pdf.cell(col_widths[i], 8, header, border=1)
    pdf.ln()

    pdf.set_font("Arial", '', 10)
    for row in resultados:
        pdf.cell(col_widths[0], 8, row['Test'], border=1)
        pdf.cell(col_widths[1], 8, row['Tipo'], border=1)
        pdf.cell(col_widths[2], 8, row['Eje'], border=1)
        pdf.cell(col_widths[3], 8, str(row['Frecuencia (Hz)']), border=1)
        pdf.cell(col_widths[4], 8, str(row['Varianza']), border=1)
        pdf.cell(col_widths[5], 8, str(row['RMS']), border=1)
        pdf.cell(col_widths[6], 8, str(row['Amplitud Max (cm)']), border=1)
        pdf.ln()

    pdf.ln(10)
    pdf.set_font("Arial", 'B', 14)
    pdf.cell(0, 10, "Diagnóstico:", ln=True)
    pdf.set_font("Arial", '', 12)
    pdf.multi_cell(0, 10, diagnostico)

    pdf.ln(10)
    for grafico in graficos:
        pdf.add_page()
        pdf.image(grafico, x=10, y=30, w=180)

    buffer = BytesIO()
    pdf.output(buffer)
    buffer.seek(0)
    return buffer

# INTERFAZ STREAMLIT
st.title("Análisis de Temblores - AirBuddy")
archivo = st.file_uploader("Subí el archivo CSV con los datos de temblores", type="csv")

if archivo:
    df = pd.read_csv(archivo)
    fs = 100  # Frecuencia de muestreo (100 Hz)
    nombre_paciente = archivo.name.split(".")[0]

    resultados_acc = calcular_resultados(df, fs, 'Aceleracion')
    resultados_gyro = calcular_resultados(df, fs, 'Giroscopio')
    resultados = resultados_acc + resultados_gyro

    st.subheader("Resultados")
    df_resultados = pd.DataFrame(resultados)
    st.dataframe(df_resultados)

    # Diagnóstico simple (se puede mejorar con IA o reglas más avanzadas)
    promedio_frecuencia = np.mean([r['Frecuencia (Hz)'] for r in resultados_acc])
    if promedio_frecuencia < 5:
        diagnostico = "El análisis sugiere un temblor de acción o postural, podría corresponder a temblor esencial."
    else:
        diagnostico = "El análisis sugiere un temblor de reposo, podría corresponder a enfermedad de Parkinson."

    # Generar gráficos
    graficos = []
    for tipo in ['Aceleracion', 'Giroscopio']:
        for eje in ['X', 'Y', 'Z']:
            columna = f'{tipo} {eje}'
            if columna in df.columns:
                fig, ax = plt.subplots()
                ax.plot(df[columna])
                ax.set_title(f'{tipo} {eje}')
                ax.set_xlabel("Muestras")
                ax.set_ylabel("Magnitud")
                buf = BytesIO()
                fig.savefig(buf, format="png")
                buf.seek(0)
                graficos.append(buf)

    # Generar PDF
    pdf_buffer = generar_pdf(nombre_paciente, resultados, graficos, diagnostico)
    b64 = base64.b64encode(pdf_buffer.read()).decode()
    href = f'<a href="data:application/octet-stream;base64,{b64}" download="{nombre_paciente}_informe.pdf">Descargar Informe PDF</a>'
    st.markdown(href, unsafe_allow_html=True)