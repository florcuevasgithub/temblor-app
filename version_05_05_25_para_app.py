# -*- coding: utf-8 -*-
"""version05/05/25_para_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/164oLbOQkEAmlnXuQR8ykWAcruH4WHeeg
"""

# --- INICIO PARA STREAMLIT ---
import streamlit as st
st.set_page_config(page_title="Análisis de Temblor", layout="centered")
# --- FIN INICIO PARA STREAMLIT ---

# Importar librerías necesarias
!pip install fpdf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft, fftfreq
from fpdf import FPDF
from google.colab import files
from datetime import datetime,timedelta
import os
from scipy.signal import butter, filtfilt, welch
from datetime import datetime

# Función para cargar y procesar cada archivo
def cargar_archivo(nombre_test):
    print(f"\nSube el archivo CSV para el test de {nombre_test}")
    uploaded = files.upload()
    for file_name in uploaded.keys():
        try:
            datos_completos = pd.read_csv(file_name)
            datos_personales = datos_completos.iloc[0, :].to_frame().T
            datos_personales.reset_index(drop=True, inplace=True)
            mediciones = datos_completos.iloc[1:, :]
            mediciones = mediciones[['Acel_X', 'Acel_Y', 'Acel_Z', 'GiroX', 'GiroY', 'GiroZ']]
            mediciones = mediciones.apply(pd.to_numeric, errors='coerce')
            return datos_personales, mediciones, file_name
        except Exception as e:
            print(f"Ocurrió un error al procesar el archivo {file_name}: {e}")
            return None, None, None

# Cargar archivos de los tres tests
nombres_tests = ['Reposo', 'Postural', 'Acción']
datos_personales, mediciones_tests, nombres_archivos = None, {}, {}
for test in nombres_tests:
    datos_personales, mediciones_tests[test], nombres_archivos[test] = cargar_archivo(test)

# Crear un DataFrame para los resultados globales
resultados_globales = pd.DataFrame(columns=['Test', 'Eje', 'Frecuencia Dominante (Hz)', 'Varianza', 'RMS', 'Máximo Desplazamiento (cm)'])

# Extraer información del paciente desde datos_personales
if datos_personales is not None:
    nombre_paciente = datos_personales.iloc[0].get('Nombre', 'No especificado')
    apellido_paciente = datos_personales.iloc[0].get('Apellido', 'No especificado')
    edad = datos_personales.iloc[0].get('Edad', 'No especificado')
    sexo = datos_personales.iloc[0].get('Sexo', 'No especificado')
    diagnostico_paciente = datos_personales.iloc[0].get('Diagnostico', 'No disponible')
    mano_paciente = datos_personales.iloc[0].get('Mano', 'No disponible')
    dedo_paciente = datos_personales.iloc[0].get('Dedo', 'No disponible')

# Mostrar información
datos_personales.head()


# ANALISIS

# Filtro pasa banda entre 3 y 12 Hz
def filtrar_temblor(signal, fs=50):
    b, a = butter(N=4, Wn=[3, 12], btype='bandpass', fs=fs)
    return filtfilt(b, a, signal)

# Análisis por ventanas
def analizar_temblor_por_ventanas(signal, fs=50, ventana_seg=2):
    signal = signal.dropna().to_numpy()
    signal_filtrada = filtrar_temblor(signal, fs)

    tamaño_ventana = int(fs * ventana_seg)
    num_ventanas = len(signal_filtrada) // tamaño_ventana

    resultados = []

    for i in range(num_ventanas):
        segmento = signal_filtrada[i*tamaño_ventana:(i+1)*tamaño_ventana]
        if len(segmento) < tamaño_ventana:
            continue

        f, Pxx = welch(segmento, fs=fs, nperseg=tamaño_ventana)
        freq_dominante = f[np.argmax(Pxx)]
        # Convertir aceleración de g a m/s² (solo si es Acel_X, Acel_Y o Acel_Z)
        if eje in ['Acel_X', 'Acel_Y', 'Acel_Z']:
            segmento = segmento * 9.81  # conversión de g a m/s²
        # Cálculo de varianza y RMS en unidades físicas correctas
        varianza = np.var(segmento)  # unidad: (m/s²)² = m²/s⁴
        rms = np.sqrt(np.mean(segmento**2))  # unidad: m/s²
        amplitud = np.max(segmento) - np.min(segmento)

        resultados.append({
            'Frecuencia Dominante (Hz)': freq_dominante,
            'Varianza (m2/s4)': varianza,
            'RMS (m/s2)': rms,
            'Amplitud Temblor (g)': amplitud
        })

    return pd.DataFrame(resultados)

# Crear tabla global de resultados promediados por señal
resultados_globales = []

# Analizar todas las señales por test y eje
for nombre_test, datos in mediciones_tests.items():
    for eje in ['Acel_X', 'Acel_Y', 'Acel_Z', 'GiroX', 'GiroY', 'GiroZ']:
        df_ventanas = analizar_temblor_por_ventanas(datos[eje], fs=50)

        if not df_ventanas.empty:
            resultado_promedio = df_ventanas.mean(numeric_only=True)
            freq = resultado_promedio['Frecuencia Dominante (Hz)']
            amp_g = resultado_promedio['Amplitud Temblor (g)']

            # Convertir a cm si la frecuencia es válida
            if freq > 0:
                amp_cm = (amp_g * 981) / ((2 * np.pi * freq) ** 2)
            else:
                amp_cm = 0.0

            resultados_globales.append({
                'Test': nombre_test,
                'Eje': eje,
                'Frecuencia Dominante (Hz)': round(freq, 2),
                'Varianza (m2/s4)': round(resultado_promedio['Varianza (m2/s4)'], 4),
                'RMS (m/s2)': round(resultado_promedio['RMS (m/s2)'], 4),
                'Amplitud Temblor (cm)': round(amp_cm, 2)
            })

# Convertir a DataFrame final
resultados_globales_df = pd.DataFrame(resultados_globales)

# Mostrar
resultados_globales_df



# diagnostico

# Diagnóstico automático según los patrones observados
def diagnosticar(resultados_df):
    temblor_reposo = resultados_df[resultados_df['Test'] == 'Reposo']
    temblor_postural = resultados_df[resultados_df['Test'] == 'Postural']
    temblor_accion = resultados_df[resultados_df['Test'] == 'Acción']

    amp_reposo = temblor_reposo['Amplitud Temblor (cm)'].max()
    amp_postural = temblor_postural['Amplitud Temblor (cm)'].max()
    amp_accion = temblor_accion['Amplitud Temblor (cm)'].max()

    freq_reposo = temblor_reposo['Frecuencia Dominante (Hz)'].mean()
    freq_postural = temblor_postural['Frecuencia Dominante (Hz)'].mean()
    freq_accion = temblor_accion['Frecuencia Dominante (Hz)'].mean()

    if amp_reposo > 0.3 and freq_reposo >= 3 and freq_reposo <= 7:
        return "Probable Parkinson"
    elif (amp_postural > 0.3 or amp_accion > 0.3) and (8 <= freq_postural <= 10 or 8 <= freq_accion <= 10):
        return "Probable Temblor Esencial"
    else:
        return "Temblor dentro de parámetros normales"

# Aplicar diagnóstico
diagnostico_calculado = diagnosticar(resultados_globales_df)

# Mostrar diagnóstico
print("\nDiagnóstico automático:", diagnostico_calculado)

import matplotlib.pyplot as plt
from datetime import datetime

# Crear gráfico de barras
def crear_grafico_resumen(df, nombre_paciente):
    resumen = df.groupby('Test')[['Frecuencia Dominante (Hz)', 'Varianza (m2/s4)', 'RMS (m/s2)', 'Amplitud Temblor (cm)']].mean()

    resumen.plot(kind='bar', figsize=(10, 6))
    plt.title(f"Resumen de Medidas - {nombre_paciente}")
    plt.ylabel("Valor")
    plt.xticks(rotation=0)
    plt.tight_layout()
    plt.savefig("grafico_resumen.png")
    plt.close()

crear_grafico_resumen(resultados_globales_df, nombre_paciente)
# PDF


fecha_hora = (datetime.now()- timedelta(hours=3)).strftime("%d/%m/%Y %H:%M")

pdf = FPDF()
pdf.add_page()
pdf.set_font("Arial", size=12)

# Título
pdf.set_font("Arial", 'B', 16)
pdf.cell(200, 10, txt="Informe de Análisis de Temblor", ln=True, align='C')

# Datos personales y fecha
pdf.set_font("Arial", size=12)
pdf.ln(10)
pdf.cell(200, 10, f"Nombre: {nombre_paciente}", ln=True)
pdf.cell(200, 10, f"Apellido: {apellido_paciente}", ln=True)
pdf.cell(200, 10, f"Edad: {edad}", ln=True)
pdf.cell(200, 10, f"Sexo: {sexo}", ln=True)
pdf.cell(200, 10, f"Diagnóstico clínico: {diagnostico_paciente}", ln=True)
pdf.cell(200, 10, f"Mano: {mano_paciente}", ln=True)
pdf.cell(200, 10, f"Dedo: {dedo_paciente}", ln=True)
pdf.cell(200, 10, f"Fecha y hora: {fecha_hora}", ln=True)

# Incluir gráfico
pdf.ln(5)
pdf.image("grafico_resumen.png", x=10, w=180)

# Tabla de resultados
pdf.ln(5)
pdf.set_font("Arial", 'B', 8)
pdf.cell(30, 10, "Test", 1)
pdf.cell(25, 10, "Eje", 1)
pdf.cell(40, 10, "Frecuencia (Hz)", 1)
pdf.cell(25, 10, "Varianza (m2/s4)", 1)
pdf.cell(25, 10, "RMS (m/s2)", 1)
pdf.cell(45, 10, "Amplitud (cm)", 1)
pdf.set_font("Arial", size=9)
pdf.ln(10)

for _, row in resultados_globales_df.iterrows():
    pdf.cell(30, 10, str(row['Test']), 1)
    pdf.cell(25, 10, str(row['Eje']), 1)
    pdf.cell(40, 10, f"{row['Frecuencia Dominante (Hz)']:.2f}", 1)
    pdf.cell(25, 10, f"{row['Varianza (m2/s4)']:.4f}", 1)
    pdf.cell(25, 10, f"{row['RMS (m/s2)']:.4f}", 1)
    pdf.cell(45, 10, f"{row['Amplitud Temblor (cm)']:.2f}", 1)
    pdf.ln(10)

# Texto de interpretación clínica
pdf.ln(10)
pdf.set_font("Arial", 'B', 12)
pdf.cell(200, 10, "Interpretación clínica:", ln=True)
pdf.set_font("Arial", size=11)
pdf.multi_cell(0, 8, """
Este informe analiza tres tipos de temblores: en reposo, postural y de acción.

Los valores de referencia considerados para la interpretación son:

-- Frecuencia característica del temblor en Parkinson: entre 3 y 6 Hz, más evidente en la prueba en reposo.

-- Frecuencia típica del temblor esencial: entre 8 y 10 Hz, generalmente más pronunciada en las pruebas postural o de acción.

-- Amplitud significativa: valores mayores a 0.3 cm en cualquier prueba pueden considerarse clínicamente relevantes.

La clasificación automática sugiere un diagnóstico probable basado en estos parámetros, aunque se recomienda su revisión por un profesional de la salud.


""")
pdf.set_font("Arial", 'B', 12)
pdf.cell(200, 10, f"Diagnóstico automático: {diagnostico_calculado}", ln=True)


# Guardar
nombre_archivo_pdf = f"{nombre_paciente}_informe_temblor.pdf"
pdf.output(nombre_archivo_pdf)
files.download(nombre_archivo_pdf)