# -*- coding: utf-8 -*-
"""version_con_reslutante.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cxmJupp0jbumyXLPIzmh8aA_4UYR2tuq
"""

import streamlit as st
import pandas as pd
import numpy as np
from scipy.signal import welch, butter, filtfilt, detrend
from fpdf import FPDF
import base64
import io
import tempfile

st.set_page_config(page_title="Análisis de Temblores", layout="centered")
st.title("Análisis de Temblores Patológicos")

# Funciones de análisis
def butter_bandpass(lowcut, highcut, fs, order=4):
    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = butter(order, [low, high], btype='band')
    return b, a

def bandpass_filter(data, lowcut=2, highcut=12, fs=100, order=4):
    b, a = butter_bandpass(lowcut, highcut, fs, order=order)
    return filtfilt(b, a, data)

def dominant_frequency(signal, fs):
    freqs, psd = welch(signal, fs)
    return freqs[np.argmax(psd)]

def compute_metrics(df, fs):
    results = []
    grouped = df.groupby('Test')

    for test_name, group in grouped:
        acel_x = detrend(group['Acel_X'].values)
        acel_y = detrend(group['Acel_Y'].values)
        acel_z = detrend(group['Acel_Z'].values)
        giro_x = detrend(group['GiroX'].values)
        giro_y = detrend(group['GiroY'].values)
        giro_z = detrend(group['GiroZ'].values)

        # Señales filtradas
        fx = bandpass_filter(acel_x)
        fy = bandpass_filter(acel_y)
        fz = bandpass_filter(acel_z)
        gx = bandpass_filter(giro_x)
        gy = bandpass_filter(giro_y)
        gz = bandpass_filter(giro_z)

        # Señal resultante
        accel_res = np.sqrt(fx**2 + fy**2 + fz**2)
        gyro_res = np.sqrt(gx**2 + gy**2 + gz**2)

        for eje, sig in zip(['Acel_X', 'Acel_Y', 'Acel_Z', 'GiroX', 'GiroY', 'GiroZ'], [fx, fy, fz, gx, gy, gz]):
            freq = dominant_frequency(sig, fs)
            var = np.var(sig)
            rms = np.sqrt(np.mean(sig**2))
            amp = 2 * np.std(sig) * 100  # cm
            results.append([test_name, eje, freq, var, rms, amp])

        # Resultante
        freq_a = dominant_frequency(accel_res, fs)
        var_a = np.var(accel_res)
        rms_a = np.sqrt(np.mean(accel_res**2))
        results.append([test_name, 'Acel_Resultante', freq_a, var_a, rms_a, np.nan])

        freq_g = dominant_frequency(gyro_res, fs)
        var_g = np.var(gyro_res)
        rms_g = np.sqrt(np.mean(gyro_res**2))
        results.append([test_name, 'Giro_Resultante', freq_g, var_g, rms_g, np.nan])

        # Promedio amplitudes
        amps = [2 * np.std(s) * 100 for s in [fx, fy, fz]]
        results.append([test_name, 'Acelerómetro (Media Amplitud)', np.nan, np.nan, np.nan, np.mean(amps)])

    columns = ['Test', 'Eje', 'Frecuencia Dominante (Hz)', 'Varianza (m2/s4)', 'RMS (m/s2)', 'Amplitud Temblor (cm)']
    return pd.DataFrame(results, columns=columns)

# Generación del informe
def generar_pdf(df, nombre_archivo):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    pdf.cell(200, 10, txt="Informe de Análisis de Temblores", ln=True, align='C')
    pdf.ln(10)

    for test in df['Test'].unique():
        pdf.set_font("Arial", style='B', size=12)
        pdf.cell(200, 10, txt=f"Test: {test}", ln=True)
        pdf.set_font("Arial", size=10)
        subdf = df[df['Test'] == test]
        for _, row in subdf.iterrows():
            linea = f"{row['Eje']}: Freq = {row['Frecuencia Dominante (Hz)']}, RMS = {row['RMS (m/s2)']}, Var = {row['Varianza (m2/s4)']}, Amp = {row['Amplitud Temblor (cm)']:.2f}"
            pdf.cell(200, 8, txt=linea, ln=True)
        pdf.ln(5)

    with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp:
        pdf.output(tmp.name)
        tmp.seek(0)
        b64 = base64.b64encode(tmp.read()).decode()
        href = f'<a href="data:application/octet-stream;base64,{b64}" download="{nombre_archivo}">Descargar informe PDF</a>'
        return href

# Interfaz Streamlit
uploaded_file = st.file_uploader("Sube un archivo CSV con los datos del test:", type="csv")

if uploaded_file is not None:
    df = pd.read_csv(uploaded_file)
    if 'Test' in df.columns:
        if st.button("Iniciar análisis"):
            resultados = compute_metrics(df, fs=100)
            st.dataframe(resultados)

            nombre_pdf = uploaded_file.name.replace(".csv", ".pdf")
            link_descarga = generar_pdf(resultados, nombre_pdf)
            st.markdown(link_descarga, unsafe_allow_html=True)
    else:
        st.error("El archivo debe contener una columna llamada 'Test'.")