# -*- coding: utf-8 -*-
"""APP-TEMBLORES-3.0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v4DIpp5J0nrnrnLmC6D6ysb8hmdwz4DN
"""

import streamlit as st
import pandas as pd
import numpy as np
from scipy.fft import fft, fftfreq
from scipy.signal import detrend, hann
from fpdf import FPDF
from datetime import datetime
import os

st.set_page_config(page_title="Análisis de Temblores", layout="wide")

st.title("Análisis de Temblores - Diagnóstico Parkinson / Temblor Esencial")

# Función para procesar una señal
def analizar_archivo(df, tipo_senal, frec_muestreo):
    resultado = {}

    # Suponemos columnas: Tiempo (s), Aceleración o Giroscopio en X, Y, Z
    t = df['Tiempo'].values
    eje = df.iloc[:, 1:4].values  # Columnas X, Y, Z

    # Inicializar resultados por eje
    frecuencias = []
    varianzas = []
    rms_list = []
    amplitudes = []

    for i in range(3):  # Ejes X, Y, Z
        señal = eje[:, i]

        # Detrend + ventana de Hann
        señal = detrend(señal - np.mean(señal))
        ventana = hann(len(señal))
        señal_vent = señal * ventana

        # FFT
        N = len(señal)
        fft_vals = np.abs(fft(señal_vent))[:N//2]
        fft_freqs = fftfreq(N, 1/frec_muestreo)[:N//2]

        # Ignorar frecuencias muy bajas (ruido) y muy altas (aliasing)
        rango_util = (fft_freqs > 0.5) & (fft_freqs < 20)
        freq_dom = fft_freqs[rango_util][np.argmax(fft_vals[rango_util])]

        # Estadísticas
        varianza = np.var(señal)
        rms = np.sqrt(np.mean(señal**2))

        # Cálculo aproximado de desplazamiento (solo para aceleración)
        if tipo_senal == "Aceleracion":
            dt = 1 / frec_muestreo
            velocidad = np.cumsum(señal) * dt
            desplazamiento = np.cumsum(velocidad) * dt
            amplitud_max = np.max(np.abs(desplazamiento))
        else:
            amplitud_max = np.max(np.abs(señal))

        frecuencias.append(freq_dom)
        varianzas.append(varianza)
        rms_list.append(rms)
        amplitudes.append(amplitud_max)

    # Promedios entre ejes
    resultado["Frecuencia (Hz)"] = round(np.mean(frecuencias), 2)
    resultado["Varianza"] = round(np.mean(varianzas), 2)
    resultado["RMS"] = round(np.mean(rms_list), 2)
    resultado["Amplitud Max (cm)"] = round(np.mean(amplitudes)*100, 2 if tipo_senal == "Aceleracion" else 2)

    return resultado

# Carga de archivos
with st.sidebar:
    st.subheader("Subir archivos de prueba")
    reposo_file = st.file_uploader("Test de Reposo", type="csv")
    postural_file = st.file_uploader("Test Postural", type="csv")
    accion_file = st.file_uploader("Test de Acción", type="csv")

if reposo_file and postural_file and accion_file:
    df_reposo = pd.read_csv(reposo_file)
    df_postural = pd.read_csv(postural_file)
    df_accion = pd.read_csv(accion_file)

    frec_muestreo = round(1 / np.mean(np.diff(df_reposo['Tiempo'].values)), 2)

    resultados = []

    for test_name, df in zip(["Reposo", "Postural", "Acción"], [df_reposo, df_postural, df_accion]):
        for tipo in ["Aceleracion", "Giroscopio"]:
            datos = analizar_archivo(df, tipo, frec_muestreo)
            datos["Test"] = test_name
            datos["Tipo"] = tipo
            resultados.append(datos)

    resultados_df = pd.DataFrame(resultados)
    st.subheader("Resultados del Análisis:")
    st.dataframe(resultados_df[["Test", "Tipo", "Frecuencia (Hz)", "Varianza", "RMS", "Amplitud Max (cm)"]])

    # Descargar PDF
    def generar_pdf(nombre_archivo, resultados_df):
        pdf = FPDF()
        pdf.add_page()
        pdf.set_font("Arial", size=12)

        pdf.cell(200, 10, txt="Informe de Análisis de Temblores", ln=True, align='C')
        pdf.cell(200, 10, txt=f"Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", ln=True, align='C')
        pdf.ln(10)

        # Tabla de resultados
        col_names = ["Test", "Tipo", "Frecuencia (Hz)", "Varianza", "RMS", "Amplitud Max (cm)"]
        col_widths = [30, 30, 40, 30, 25, 40]
        for i, col in enumerate(col_names):
            pdf.cell(col_widths[i], 10, col, border=1, align='C')
        pdf.ln()

        for _, row in resultados_df.iterrows():
            for i, col in enumerate(col_names):
                pdf.cell(col_widths[i], 10, str(row[col]), border=1, align='C')
            pdf.ln()

        pdf.output(nombre_archivo)

    if st.button("Generar PDF"):
        archivo_pdf = "informe_temblores.pdf"
        generar_pdf(archivo_pdf, resultados_df)
        with open(archivo_pdf, "rb") as f:
            st.download_button("Descargar PDF", f, file_name=archivo_pdf)

else:
    st.warning("Por favor, subí los tres archivos (reposo, postural y acción).")